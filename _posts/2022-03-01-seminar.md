---
title:  "안드로이드에서의 thread(스레드)/MVVM/RecyclerView(리사이클러뷰)"
excerpt: "안드로이드, thread, MVVM, RecyclerView"
toc: true
toc_sticky: true
header:
  teaser: /assets/images/20220227_handler_1.png

categories:
  - Android
tags:
  - android
  - kotlin
last_modified_at: 2022-03-01
---

## 목차

1. 안드로이드에서의 스레드(Thread)
   * 구성
   * 스레드의 3가지 유형
   * 코루틴(Coroutine)이란?
   * 코루틴 키워드
   * 활용
2. 앱 개발을 대표하는 디자인 패턴: MVVM
   * MVVM 용어의 이해
   * 구현요소
   * 활용
3. 리사이클러뷰(Recycler View)
   * 개념과 사용 목적
   * 작동원리
   * 활용
4. 참고        



## 스레드(Thread) for Android

#### 구성

+ 스레드: 프로그램 내에서 실행되는 흐름의 단위        
  *  단일 작업만 필요하다면? :arrow_forward: 스레드 1개 동작
  *  다중 작업이 필요하다면? :arrow_forward: 스레드 2개 이상 동작
+ 핸들러: 다른 스레드가 보낸 메시지를 받고 처리하는 객체. 스레드 메시지큐와 함께 사용됨
  * 스레드와 핸들러는 1대1 대응
  * **루퍼(Looper)**와 연결되어 생성된다.

<img src="/assets/images/20220227_handler_1.png">


#### :computer: 활용

```kotlin
val handler = Handler(Looper.getMainLooper()) 
val runnable = Runnable {
  val intent = Intent(this, MainActivity::class.java) startActivity(intent) 
  finish() 
} 
handler.postDelayed(runnable, 3000)
animationView.setOnClickListener{
  handler.removeCallbacks(runnable) 
  val intent = Intent(this, MainActivity::class.java) 
  startActivity(intent) 
  finish() 
}
```

* 핸들러는 루퍼와 연결되어 생성되기 때문에 생성 인자로 루퍼를 넘겨준다.             

* getMainLooper(): Main스레드의 Looper를 가져온다는 뜻. **여기서 잠깐!**  MainLooper를 생성하는 코드는 없는데 어떻게 가져올 수 있을까? :arrow_forward: MainLooper는 안드로이드 자체에서 만들어두기 때문이다. 따라서 Main스레드가 아니라 다른 스레드에서 동작하는 작업이라면 따로 루퍼를 만들어야한다!            

* Runnable: 스레드에서 동작할 수 있는 객체를 구현할 수 있는 인터페이스          

* postDelayed(runnable, long): long의 밀리세컨드만큼 기다린 뒤에 runnable 객체를 수행시켜라 
**추가적으로 post(바로 실행)와 postAtTime(시간 지정)함수도 있음**    

* Handler.removeCallbacks: 메시지큐에 들어있는 메시지를 삭제한다.      



#### 스레드의 3가지 유형

* Main: UI와 상호작용하는 작업을 실행하는데 최적화되어 있다.
* IO: 디스크 또는 네트워크 I/O 작업을 실행하는데 최적화되어 있다.
* Default: CPU를 많이 사용하는 작업을 기본 스레드 외부에서 실행하도록 최적화되어 있다. 정렬 작업이나 JSON 파싱 작업 등에 사용된다.

#### 코루틴이란?

스레드/비동기 작업/백그라운드 작업을 할 수 있는 **경량스레드**이다.    

* 코루틴은 JVM heap 안의 작은 객체에 연결되어있다. (반면, 스레드는 OS에 해당하는 native스레드와 연결되어있고 자원의 상당부분을 소비해서 CPU에 부담을 주기 쉽다.)
* 코루틴 전환시 Context Switch가 일어나지 않는다. 애초에 코루틴은 OS 커널에 연결되어있지 않기 때문이다. (반면, 스레드는 OS 커널과 연결되어 있기 때문에 전환시 CPU 사이클을 꽤 소비한다.)
* 실행과 중단을 지정할 수 있다.



#### 코루틴 키워드

* Scope
  * Coroutine Scope: 코루틴 블록 묶음, 코루틴으로 제어할 수 있는 단위
  * Global Scope: 컴포넌트의 Lifecycle과 무관하게 싱글톤으로 어플리케이션 생명주기에 따라 동작하는 코루틴

* Coroutine Context: 실행상태 정보의 집합
  * Job: 1개 이상의 코루틴 동작을 제어함
  * Dispatcher: 코루틴 실행을 특정 스레드로 한정 시킴, 스레드의 제한 없이 실행되도록 함(다양한 스레드에서 실행시킬 수 있다.), 어떤 스레드를 어떻게 동작시킬 것인가 정의

<img src="/assets/images/20220227_dispatcher_1.png">      


<img src="/assets/images/20220227_dispatcher_2.png">      


<img src="/assets/images/20220227_dispatcher_3.png">      


* launch()/async(): 코루틴을 만들고 실행하는 코루틴 빌더
  * launch(): 객체로 Job()을 반환하고 반환 값은 없다.
  * async(): 객체로 Deferred<T>를 반환하고 반환 값이 존재한다.

#### :computer:활용

```kotlin
suspend fun main(){
  val deferred: Deferred<String> = 
  	CoroutineScope(Dispatchers.IO).async {
      "Deferred Result"
    }
  val defferedResult = deferred.await()	// 코루틴 반환 값을 받을 때까지 일시중단
  Log.d("결과 값", deferredResult)
}
```

## 앱 개발 대표 디자인 패턴: MVVM

#### MVVM 용어의 이해

* Model-View-Viewmodel의 약어
* View와 Model을 Viewmodel로 분리하여 뷰가 어느 특정한 모델 플랫폼에 종속되지 않도록 해준다.
* View와 Viewmodel가 데이터바인딩으로 연결되어 Viewmodel의 속성이 가지는 데이터가 변경될 때 마다 View를 업데이트시켜줄 수 있다. 

<img src="/assets/images/20220227_MVVM_1.png">      

#### 구현요소

* LiveData: 관찰 가능한 데이터 홀더 클래스. 활성 관찰자에게 업데이트 정보를 알린다.
* Observer: LiveData 객체가 보유한 데이터 변경 시 발생하는 작업을 제어하는 인터페이스. 코틀린에서는 listener라고도 함. 
* observe: LiveData 클래스의 메서드. LiveData와 Observer를 연결해준다. 
  

1. LiveData로 변경될 수 있는 데이터를 가지는 데이터 홀더 클래스를 만든다.
2. LiveData가 변경되었을 때 동작해야하는 코드를 Observer 인터페이스를 이용해 정의한다.
3. LiveData의 메서드인 observe로 정의한 Observer 객체를 연결한다.
4. LiveData가 변경되었을 때 연결된 Observer객체가 변경사항에 관한 알림을 받아 정의된 코드를 실행한다. 



<img src="/assets/images/20220227_MVVM_2.png">       


#### :computer:활용           

* ViewModel

````kotlin
class HomeViewModel(application: Application): AndroidViewModel(application){
    private var listenerRgst:ListenerRegistration? = null
    private var _userSnapshot:MutableLiveData<DocumentSnapshot> = MutableLiveData<DocumentSnapshot>()
    val userSnapshot: LiveData<DocumentSnapshot> = _userSnapshot	// View에는 LiveData만 노출(MutableLiveData X)
    val mapplication = application

    fun getUserSnapshot(){
        if (listenerRgst == null) {
            val firebaseRepo = FirebaseRepository(mapplication)
            listenerRgst = firebaseRepo.getUserSnapshot(_userSnapshot)	// 모델로부터 데이터 읽음
        }
    }

    fun setUserSnapshot(snapshot: DocumentSnapshot){
      	val firebaseRepo = FirebaseRepository(mapplication)
        _userSnapshot.value = snapshot	// LiveData에 변경된 데이터 삽입
      	firebaseRepo.setUserSnapshot(_userSnapshot)	// 모델에 데이터 업데이트
    }

   ...
}
````



* View

```kotlin
class HomeFragment : Fragment() {
  ...
  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // LiveDate의 value가 it으로 들어감
        homeViewModel.userSnapshot.observe(viewLifecycleOwner){
            initUserView(it)	// userSnapshot이 변경될 때 이 메서드가 동작
        }
    ...
  }
  
  private fun initUserView(snapshot: DocumentSnapshot){...}
  ...
}
```


## 리사이클러뷰(RecyclerView)

#### 개념과 사용목적

* 스크롤 목록 구현
* ListView를 개선한 View :arrow_forward: 더 효율적이고 유연하다.
* 목록을 구성하는 항목들을 **재활용(Recycler)**한다.
* 자유롭게 커스터마이징할 수 있다.
* 집필 시점에 안드로이드 공식 사이트에서 목록을 구현할 때 ListView보다 RecyclerView를 사용하라고 권장하고있다.


#### 작동원리

<img src="/assets/images/20220227_RecyclerView_1.png">      

* LayoutManager: 수직/수평으로 지정된 형식대로 RecyclerView의 데이터를 배치시켜준다. 수직 방향이 디폴트다.
* Adapter(RecyclerView.Adapter)
  * RecyclerView를 상속받는 클래스
  * 데이터를 아이템(항목)에 제공하는 역할
  * 내부에 RecyclerView.ViewHolder 클래스와 onCreateViewHolder, onBindViewHolder, getItemCount 함수가 포함되어야한다.
  * RecyclerView.ViewHolder :arrow_forward: RecyclerView 내부의 View의 정보를 가지고있는 추상 클래스
  * onCreateViewHolder :arrow_forward: RecyclerView.ViewHolder 객체를 생성하고 반환한다. RecyclerView에서 새 항목이 필요할 때(화면에 새 항목이 보여질 때) 호출된다.
  * onBindViewHolder :arrow_forward: 항목에 포함되어 있는 View의 데이터를 업데이트 해준다. 각 항목의 position을 인자로 받는다. 항목이 재사용될 수 있도록하는 메서드이다.
  * getItemCount :arrow_forward: RecyclerView의 항목 전체 개수를 반환한다.


#### :computer: 활용

````kotlin
class SendAdapter(private var postLi: ArrayList<Note>)
    : RecyclerView.Adapter<SendAdapter.ViewHolder>(){

    inner class ViewHolder(view: ItemSendRecyclerBinding):
      RecyclerView.ViewHolder(view.root){	// 리사이클러뷰의 뷰홀더를 상속받아 정의
        // 항목 하나를 구성하는(속해있는) View를 받는다.
        val txtFromName = view.txtFromName
        val txtPreview = view.txtPreview
        val circleImg = view.circleImageView
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int):
      ViewHolder {	
        val view =
      ItemSendRecyclerBinding.inflate(LayoutInflater.from(parent.context), 					parent, false)	// 항목 레이아웃 xml의 내용을 가져온다.
        return ViewHolder(view)		// 내부 클래스인 ViewHolder 생성
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
      // 각 항목의 순번 인덱스가 position 인자로 들어간다.
        postLi!!.get(position).let { item ->
            with(holder){
                txtFromName.text = item.name	// 텍스트뷰1 세팅
                val arr = item.text.replace("\n","")
                txtPreview.text = arr	// 텍스트뷰2 세팅
     						circleImg.setImageResource(	// 이미지뷰 세팅
       					MainActivity.profileImgLi[item.profileImg])
                itemView.setOnClickListener {	// 항목 자체가 클릭됐을 때
                    itemClickListener.onItemClick(it, position)
                }
            }
        }
    }

    override fun getItemCount(): Int {	// 항목 전체 개수
        return postLi.size
    }
    
    ...
}
````
  

## 참고

* 안드로이드 공식, Thread: https://developer.android.com/reference/java/lang/Thread
* 안드로이드 공식, Handler: https://developer.android.com/reference/android/os/Handler
* 안드로이드 공식, Looper: https://developer.android.com/reference/android/os/Looper?hl=nl-BE#getMainLooper()
* Kotlin Coroutines의 GlobalScope을 어떻게 사용할 수 있을까?: https://thdev.tech/kotlin/2020/12/22/kotlin_effective_16/
* 코루틴 공식 가이드 자세히 읽기: https://myungpyo.medium.com/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B3%B5%EC%8B%9D-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%9D%BD%EA%B8%B0-part-5-62e886f7862d
* Coroutine의 Dispatcher 란 무엇인가?: https://myungpyo.medium.com/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B3%B5%EC%8B%9D-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%9D%BD%EA%B8%B0-part-5-62e886f7862d
* 안드로이드 공식, Observer: https://developer.android.com/reference/androidx/lifecycle/Observer
* 작성자 깃헙(코드참고): https://github.com/YeeunLee8245/MyWriting-AndroidApp
* 위키백과, MVVM: https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EB%B7%B0%EB%AA%A8%EB%8D%B8
* MVVM 패턴, Observer 패턴: https://jhy156456.tistory.com/entry/MVVM-%ED%8C%A8%ED%84%B4
* 안드로이드 공식, RecyclerView: https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html
* 안드로이드 리사이클러뷰 기본 사용법: https://recipes4dev.tistory.com/154
